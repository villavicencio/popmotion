'use strict';

exports.__esModule = true;
exports.default = cubicBezier;
/*
  Bezier function generator
    
  GaÃ«tan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/index.js  
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  You're a hero
  
  Use
  
    var easeOut = new Bezier(.17,.67,.83,.67),
      x = easeOut(0.5); // returns 0.627...
*/

// Constants
var NEWTON_ITERATIONS = 8;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;
var K_SPLINE_TABLE_SIZE = 11;
var K_SAMPLE_STEP_SIZE = 1.0 / (K_SPLINE_TABLE_SIZE - 1.0);
var FLOAT_32_SUPPORTED = typeof Float32Array !== 'undefined';

// Helper methods
var a = function (a1, a2) {
  return 1.0 - 3.0 * a2 + 3.0 * a1;
};
var b = function (a1, a2) {
  return 3.0 * a2 - 6.0 * a1;
};
var c = function (a1) {
  return 3.0 * a1;
};

var getSlope = function (t, a1, a2) {
  return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);
};

var calcBezier = function (t, a1, a2) {
  return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;
};

/*
  Create a cubic bezier resolver
*/
function cubicBezier(mX1, mY1, mX2, mY2) {
  var sampleValues = FLOAT_32_SUPPORTED ? new Float32Array(K_SPLINE_TABLE_SIZE) : new Array(K_SPLINE_TABLE_SIZE);
  var _precomputed = false;

  var binarySubdivide = function (aX, aA, aB) {
    var i = 0;
    var currentX = void 0;
    var currentT = void 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  };

  var newtonRaphsonIterate = function (aX, aGuessT) {
    var i = 0;
    var currentSlope = 0;
    var currentX = void 0;

    for (; i < NEWTON_ITERATIONS; ++i) {
      currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  };

  var calcSampleValues = function () {
    for (var i = 0; i < K_SPLINE_TABLE_SIZE; ++i) {
      sampleValues[i] = calcBezier(i * K_SAMPLE_STEP_SIZE, mX1, mX2);
    }
  };

  var getTForX = function (aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = K_SPLINE_TABLE_SIZE - 1;
    var dist = 0.0;
    var guessForT = 0.0;
    var initialSlope = 0.0;

    for (; currentSample != lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += K_SAMPLE_STEP_SIZE;
    }

    --currentSample;

    dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    guessForT = intervalStart + dist * K_SAMPLE_STEP_SIZE;

    initialSlope = getSlope(guessForT, mX1, mX2);

    // If slope is greater than min
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT);
      // Slope is equal to min
    } else if (initialSlope === 0.0) {
      return guessForT;
      // Slope is less than min
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + K_SAMPLE_STEP_SIZE);
    }
  };

  var precompute = function () {
    _precomputed = true;
    if (mX1 != mY1 || mX2 != mY2) {
      calcSampleValues();
    }
  };

  var resolver = function (aX) {
    var returnValue = void 0;

    if (!_precomputed) {
      precompute();
    }

    // If linear gradient, return X as T
    if (mX1 === mY1 && mX2 === mY2) {
      returnValue = aX;

      // If at start, return 0
    } else if (aX === 0) {
      returnValue = 0;

      // If at end, return 1
    } else if (aX === 1) {
      returnValue = 1;
    } else {
      returnValue = calcBezier(getTForX(aX), mY1, mY2);
    }

    return returnValue;
  };

  return resolver;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hY3Rpb25zL2Vhc2luZy9jcmVhdGUtYmV6aWVyLmpzIl0sIm5hbWVzIjpbImN1YmljQmV6aWVyIiwiTkVXVE9OX0lURVJBVElPTlMiLCJORVdUT05fTUlOX1NMT1BFIiwiU1VCRElWSVNJT05fUFJFQ0lTSU9OIiwiU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMiLCJLX1NQTElORV9UQUJMRV9TSVpFIiwiS19TQU1QTEVfU1RFUF9TSVpFIiwiRkxPQVRfMzJfU1VQUE9SVEVEIiwiRmxvYXQzMkFycmF5IiwiYSIsImExIiwiYTIiLCJiIiwiYyIsImdldFNsb3BlIiwidCIsImNhbGNCZXppZXIiLCJtWDEiLCJtWTEiLCJtWDIiLCJtWTIiLCJzYW1wbGVWYWx1ZXMiLCJBcnJheSIsIl9wcmVjb21wdXRlZCIsImJpbmFyeVN1YmRpdmlkZSIsImFYIiwiYUEiLCJhQiIsImkiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwiTWF0aCIsImFicyIsIm5ld3RvblJhcGhzb25JdGVyYXRlIiwiYUd1ZXNzVCIsImN1cnJlbnRTbG9wZSIsImNhbGNTYW1wbGVWYWx1ZXMiLCJnZXRURm9yWCIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImRpc3QiLCJndWVzc0ZvclQiLCJpbml0aWFsU2xvcGUiLCJwcmVjb21wdXRlIiwicmVzb2x2ZXIiLCJyZXR1cm5WYWx1ZSJdLCJtYXBwaW5ncyI6Ijs7O2tCQW1Dd0JBLFc7QUFuQ3hCOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0EsSUFBTUMsb0JBQW9CLENBQTFCO0FBQ0EsSUFBTUMsbUJBQW1CLEtBQXpCO0FBQ0EsSUFBTUMsd0JBQXdCLFNBQTlCO0FBQ0EsSUFBTUMsNkJBQTZCLEVBQW5DO0FBQ0EsSUFBTUMsc0JBQXNCLEVBQTVCO0FBQ0EsSUFBTUMscUJBQXFCLE9BQU9ELHNCQUFzQixHQUE3QixDQUEzQjtBQUNBLElBQU1FLHFCQUFzQixPQUFPQyxZQUFQLEtBQXdCLFdBQXBE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QixFQUE4QjtBQUM1QmdCO0FBQ0Q7QUFDRixHQUxEOztBQU9BLE1BQU1TLFdBQVcsVUFBQ3BCLEVBQUQsRUFBUTtBQUN2QixRQUFJcUIsb0JBQUo7O0FBRUEsUUFBSSxDQUFDdkIsWUFBTCxFQUFtQjtBQUNqQnFCO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFJM0IsUUFBUUMsR0FBUixJQUFlQyxRQUFRQyxHQUEzQixFQUFnQztBQUM5QjBCLG9CQUFjckIsRUFBZDs7QUFFRjtBQUNDLEtBSkQsTUFJTyxJQUFJQSxPQUFPLENBQVgsRUFBYztBQUNuQnFCLG9CQUFjLENBQWQ7O0FBRUY7QUFDQyxLQUpNLE1BSUEsSUFBSXJCLE9BQU8sQ0FBWCxFQUFjO0FBQ25CcUIsb0JBQWMsQ0FBZDtBQUVELEtBSE0sTUFHQTtBQUNMQSxvQkFBYzlCLFdBQVdxQixTQUFTWixFQUFULENBQVgsRUFBeUJQLEdBQXpCLEVBQThCRSxHQUE5QixDQUFkO0FBQ0Q7O0FBRUQsV0FBTzBCLFdBQVA7QUFDRCxHQXhCRDs7QUEwQkEsU0FBT0QsUUFBUDtBQUNEIiwiZmlsZSI6ImNyZWF0ZS1iZXppZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBCZXppZXIgZnVuY3Rpb24gZ2VuZXJhdG9yXG4gICAgXG4gIEdhw6t0YW4gUmVuYXVkZWF1J3MgQmV6aWVyRWFzaW5nXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZy9ibG9iL21hc3Rlci9pbmRleC5qcyAgXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmUvYmV6aWVyLWVhc2luZy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gIFlvdSdyZSBhIGhlcm9cbiAgXG4gIFVzZVxuICBcbiAgICB2YXIgZWFzZU91dCA9IG5ldyBCZXppZXIoLjE3LC42NywuODMsLjY3KSxcbiAgICAgIHggPSBlYXNlT3V0KDAuNSk7IC8vIHJldHVybnMgMC42MjcuLi5cbiovXG5cbi8vIENvbnN0YW50c1xuY29uc3QgTkVXVE9OX0lURVJBVElPTlMgPSA4O1xuY29uc3QgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xuY29uc3QgU1VCRElWSVNJT05fUFJFQ0lTSU9OID0gMC4wMDAwMDAxO1xuY29uc3QgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcbmNvbnN0IEtfU1BMSU5FX1RBQkxFX1NJWkUgPSAxMTtcbmNvbnN0IEtfU0FNUExFX1NURVBfU0laRSA9IDEuMCAvIChLX1NQTElORV9UQUJMRV9TSVpFIC0gMS4wKTtcbmNvbnN0IEZMT0FUXzMyX1NVUFBPUlRFRCA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyk7XG5cbi8vIEhlbHBlciBtZXRob2RzXG5jb25zdCBhID0gKGExLCBhMikgPT4gMS4wIC0gMy4wICogYTIgKyAzLjAgKiBhMTtcbmNvbnN0IGIgPSAoYTEsIGEyKSA9PiAzLjAgKiBhMiAtIDYuMCAqIGExO1xuY29uc3QgYyA9IChhMSkgPT4gMy4wICogYTE7XG5cbmNvbnN0IGdldFNsb3BlID0gKHQsIGExLCBhMikgPT4gMy4wICogYShhMSwgYTIpICogdCAqIHQgKyAyLjAgKiBiKGExLCBhMikgKiB0ICsgYyhhMSk7XG5cbmNvbnN0IGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKGEoYTEsIGEyKSAqIHQgKyBiKGExLCBhMikpICogdCArIGMoYTEpKSAqIHQ7XG5cbi8qXG4gIENyZWF0ZSBhIGN1YmljIGJlemllciByZXNvbHZlclxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBGTE9BVF8zMl9TVVBQT1JURUQgPyBuZXcgRmxvYXQzMkFycmF5KEtfU1BMSU5FX1RBQkxFX1NJWkUpIDogbmV3IEFycmF5KEtfU1BMSU5FX1RBQkxFX1NJWkUpO1xuICBsZXQgX3ByZWNvbXB1dGVkID0gZmFsc2U7XG5cbiAgY29uc3QgYmluYXJ5U3ViZGl2aWRlID0gKGFYLCBhQSwgYUIpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGN1cnJlbnRYO1xuICAgIGxldCBjdXJyZW50VDtcblxuICAgIGRvIHtcbiAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhQSA9IGN1cnJlbnRUO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG5cbiAgICByZXR1cm4gY3VycmVudFQ7XG4gIH07XG5cbiAgY29uc3QgbmV3dG9uUmFwaHNvbkl0ZXJhdGUgPSAoYVgsIGFHdWVzc1QpID0+IHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGN1cnJlbnRTbG9wZSA9IDA7XG4gICAgbGV0IGN1cnJlbnRYO1xuXG4gICAgZm9yICg7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgICBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICBcbiAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgYUd1ZXNzVCAtPSBjdXJyZW50WCAvIGN1cnJlbnRTbG9wZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFHdWVzc1Q7XG4gIH07XG5cbiAgY29uc3QgY2FsY1NhbXBsZVZhbHVlcyA9ICgpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IEtfU1BMSU5FX1RBQkxFX1NJWkU7ICsraSkge1xuICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICogS19TQU1QTEVfU1RFUF9TSVpFLCBtWDEsIG1YMik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGdldFRGb3JYID0gKGFYKSA9PiB7XG4gICAgbGV0IGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgbGV0IGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgIGxldCBsYXN0U2FtcGxlID0gS19TUExJTkVfVEFCTEVfU0laRSAtIDE7XG4gICAgbGV0IGRpc3QgPSAwLjA7XG4gICAgbGV0IGd1ZXNzRm9yVCA9IDAuMDtcbiAgICBsZXQgaW5pdGlhbFNsb3BlID0gMC4wO1xuICAgICAgXG4gICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBLX1NBTVBMRV9TVEVQX1NJWkU7XG4gICAgfVxuICAgIFxuICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICBcbiAgICBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSsxXSAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBLX1NBTVBMRV9TVEVQX1NJWkU7XG4gICAgXG4gICAgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgXG4gICAgLy8gSWYgc2xvcGUgaXMgZ3JlYXRlciB0aGFuIG1pblxuICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQpO1xuICAgIC8vIFNsb3BlIGlzIGVxdWFsIHRvIG1pblxuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgLy8gU2xvcGUgaXMgbGVzcyB0aGFuIG1pblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsgS19TQU1QTEVfU1RFUF9TSVpFKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcHJlY29tcHV0ZSA9ICgpID0+IHtcbiAgICBfcHJlY29tcHV0ZWQgPSB0cnVlO1xuICAgIGlmIChtWDEgIT0gbVkxIHx8IG1YMiAhPSBtWTIpIHtcbiAgICAgIGNhbGNTYW1wbGVWYWx1ZXMoKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVzb2x2ZXIgPSAoYVgpID0+IHtcbiAgICBsZXQgcmV0dXJuVmFsdWU7XG5cbiAgICBpZiAoIV9wcmVjb21wdXRlZCkge1xuICAgICAgcHJlY29tcHV0ZSgpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiBsaW5lYXIgZ3JhZGllbnQsIHJldHVybiBYIGFzIFRcbiAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgIHJldHVyblZhbHVlID0gYVg7XG4gICAgICBcbiAgICAvLyBJZiBhdCBzdGFydCwgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKGFYID09PSAwKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IDA7XG4gICAgICBcbiAgICAvLyBJZiBhdCBlbmQsIHJldHVybiAxXG4gICAgfSBlbHNlIGlmIChhWCA9PT0gMSkge1xuICAgICAgcmV0dXJuVmFsdWUgPSAxO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVyblZhbHVlID0gY2FsY0JlemllcihnZXRURm9yWChhWCksIG1ZMSwgbVkyKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIHJldHVybiByZXNvbHZlcjtcbn1cbiJdfQ==